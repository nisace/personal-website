<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-11-14">
<meta name="description" content="Post about how to perform streamable neural audio synthesis.">

<title>Streamable Neural Audio Synthesis With Non-Causal Convolutions – Nisace’s website</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-c1fac2584b48ed01fb6e278e36375074.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Nisace’s website</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#problem-formulation" id="toc-problem-formulation" class="nav-link" data-scroll-target="#problem-formulation">Problem formulation</a></li>
  <li><a href="#possible-solutions" id="toc-possible-solutions" class="nav-link" data-scroll-target="#possible-solutions">Possible solutions</a>
  <ul class="collapse">
  <li><a href="#overlap-add" id="toc-overlap-add" class="nav-link" data-scroll-target="#overlap-add">Overlap-add</a></li>
  <li><a href="#causal-convolutions" id="toc-causal-convolutions" class="nav-link" data-scroll-target="#causal-convolutions">Causal convolutions</a></li>
  </ul></li>
  <li><a href="#proposed-solution" id="toc-proposed-solution" class="nav-link" data-scroll-target="#proposed-solution">Proposed solution</a>
  <ul class="collapse">
  <li><a href="#convolution-layers-with-stride-1" id="toc-convolution-layers-with-stride-1" class="nav-link" data-scroll-target="#convolution-layers-with-stride-1">Convolution layers with <span class="math inline">\(stride = 1\)</span></a>
  <ul class="collapse">
  <li><a href="#layer-1" id="toc-layer-1" class="nav-link" data-scroll-target="#layer-1">Layer 1</a></li>
  <li><a href="#layer-2" id="toc-layer-2" class="nav-link" data-scroll-target="#layer-2">Layer 2</a></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">Summary</a></li>
  </ul></li>
  <li><a href="#convolution-layers-with-stride-1-1" id="toc-convolution-layers-with-stride-1-1" class="nav-link" data-scroll-target="#convolution-layers-with-stride-1-1">Convolution layers with <span class="math inline">\(stride &gt; 1\)</span></a>
  <ul class="collapse">
  <li><a href="#layer-1-1" id="toc-layer-1-1" class="nav-link" data-scroll-target="#layer-1-1">Layer 1</a></li>
  <li><a href="#layer-2-1" id="toc-layer-2-1" class="nav-link" data-scroll-target="#layer-2-1">Layer 2</a></li>
  <li><a href="#summary-1" id="toc-summary-1" class="nav-link" data-scroll-target="#summary-1">Summary</a></li>
  <li><a href="#notes-on-the-continuity-between-buffers" id="toc-notes-on-the-continuity-between-buffers" class="nav-link" data-scroll-target="#notes-on-the-continuity-between-buffers">Notes on the continuity between buffers</a></li>
  </ul></li>
  <li><a href="#convolution-layers-summary" id="toc-convolution-layers-summary" class="nav-link" data-scroll-target="#convolution-layers-summary">Convolution layers summary</a></li>
  <li><a href="#parallel-branches" id="toc-parallel-branches" class="nav-link" data-scroll-target="#parallel-branches">Parallel branches</a></li>
  </ul></li>
  <li><a href="#sources" id="toc-sources" class="nav-link" data-scroll-target="#sources">Sources</a>
  <ul class="collapse">
  <li><a href="#papers" id="toc-papers" class="nav-link" data-scroll-target="#papers">Papers</a></li>
  <li><a href="#code" id="toc-code" class="nav-link" data-scroll-target="#code">Code</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Streamable Neural Audio Synthesis With Non-Causal Convolutions</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Machine Learning</div>
    <div class="quarto-category">Neural Audio Synthesis</div>
  </div>
  </div>

<div>
  <div class="description">
    <p>Post about how to perform streamable neural audio synthesis.</p>
  </div>
</div>


<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 14, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>This post dives into how to perform streamable neural audio synthesis. It is based on the following two papers:</p>
<ul>
<li><p><a href="https://arxiv.org/abs/2111.05011">RAVE: A variational autoencoder for fast and high-quality neural audio synthesis</a></p>
<ul>
<li><p>This paper introduces the RAVE model which is a <a href="../../posts/variational-autoencoders/index.html">variational autoencoder</a> trained in two stages:</p>
<ul>
<li><p>First the regular variational autoencoder training,</p></li>
<li><p>Followed by an additional adversarial training stage for the decoder.</p></li>
</ul></li>
<li><p>See the <a href="../../posts/rave_introduction/index.html">Short introduction to the RAVE model</a> post for more details.</p></li>
</ul></li>
<li><p><a href="https://arxiv.org/abs/2204.07064">Streamable Neural Audio Synthesis With Non-Causal Convolutions</a></p>
<ul>
<li>This paper introduces a post-training reconfiguration of convolutional networks that allows to turn them into streamable models (for example the RAVE model as it is introduced in the RAVE paper, is not directly streamable and thus, requires this type of post-training reconfiguration).</li>
</ul></li>
</ul>
<p>The <a href="https://arxiv.org/abs/2204.07064">Streamable Neural Audio Synthesis With Non-Causal Convolutions paper</a> is about how to process a stream of audio data. Usually:</p>
<ul>
<li><p>The input data comes as a sequence of audio chunks called buffers.</p></li>
<li><p>Each buffer is processed sequentially.</p></li>
<li><p>The outputs are concatenated to produce the output audio stream.</p></li>
</ul>
</section>
<section id="problem-formulation" class="level1">
<h1>Problem formulation</h1>
<p>However, there are some challenges:</p>
<ul>
<li><p>As explained in the <a href="../../posts/rave_introduction/index.html#encoder">Encoder</a> section of the <a href="../../posts/rave_introduction/index.html">Short introduction to the RAVE model</a> post, the convolution layers usually use padding to maintain the time alignment between the inputs and outputs across layers.</p></li>
<li><p>This creates discontinuities between buffers.</p></li>
<li><p>These discontinuities can cause audible artifacts.</p>
<ul>
<li><p>They are mainly due to phase discontinuities.</p>
<ul>
<li><p>This is because the phase changes much faster than the amplitude (at every sample for periodic signals).</p></li>
<li><p>Thus, it is much more sensitive to the discontinuities between buffers.</p></li>
</ul></li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/drawing_1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="1000"></p>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/drawing_2.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="350"></p>
</figure>
</div>
</section>
<section id="possible-solutions" class="level1">
<h1>Possible solutions</h1>
<section id="overlap-add" class="level2">
<h2 class="anchored" data-anchor-id="overlap-add">Overlap-add</h2>
<ul>
<li><p>Process overlapping buffers and blend them to smooth boundaries.</p></li>
<li><p>This solution is compatible with any generative model.</p></li>
<li><p>However, it requires redundant computations and leads to degraded quality during transition phases.</p></li>
<li><p>It also requires to cache buffers that are large enough to fill the receptive field of the model.</p></li>
<li><p>All of this results in high latency.</p></li>
</ul>
</section>
<section id="causal-convolutions" class="level2">
<h2 class="anchored" data-anchor-id="causal-convolutions">Causal convolutions</h2>
<ul>
<li><p>Use causal convolutional neural networks with cached padding as in the <a href="https://arxiv.org/abs/2005.06720">Streaming keyword spotting on mobile devices</a> paper.</p></li>
<li><p>The idea is to put all the padding on the left side of the audio chunk (the side that corresponds to the values in the past).</p></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/drawing_3.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="1000"></p>
</figure>
</div>
<ul>
<li><p>Then, each audio chunk (except the first one) is padded with the end of the previous audio chunk (hence the name causal, because each chunk is padded with values from the past but is not padded with values from the future).</p></li>
<li><p>This solution preserves continuity between chunks.</p></li>
<li><p>However, it restricts the model architectures to causal convolutions which makes learning more complex because the model is not given access to the values in the future during training even though they are available (because training is not done in a streaming way).</p></li>
</ul>
</section>
</section>
<section id="proposed-solution" class="level1">
<h1>Proposed solution</h1>
<ul>
<li><p>The paper proposes to perform a post-training causal reconfiguration of the model.</p></li>
<li><p>This allows to consider convolutional networks trained using any type of padding (potentially non-causal) and turn them into streamable models.</p></li>
<li><p>The main idea is to remove the right padding (on the future side) and replace it with an additional left padding (on the past side).</p></li>
<li><p>The main challenge of such a reconfiguration is to leave the computational graph of the model unchanged.</p></li>
<li><p>Indeed, depending on the configuration of each layer, the additional left padding can break the time alignment between its inputs and outputs.</p></li>
<li><p>Thus, the paper proposes to keep track of the delay cumulated at each new layer and to introduce additional delays in the graph to restore the time alignment.</p></li>
</ul>
<p>Below are some detailed explanations for different layer configurations.</p>
<ul>
<li><p><span class="math inline">\(D_{l}\)</span> is the delay introduced by layer <span class="math inline">\(l\)</span>.</p></li>
<li><p><span class="math inline">\({Cumulated\ Delay}_{l}\)</span> is the delay cumulated from the first layer up to layer <span class="math inline">\(l\)</span>.</p></li>
<li><p>The following color legend is used</p></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/drawing_4.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="350"></p>
</figure>
</div>
<section id="convolution-layers-with-stride-1" class="level2">
<h2 class="anchored" data-anchor-id="convolution-layers-with-stride-1">Convolution layers with <span class="math inline">\(stride = 1\)</span></h2>
<p>The figure below represents 2 convolution layers before the causal reconfiguration</p>
<ul>
<li><p>Layer 1</p>
<ul>
<li><p><span class="math inline">\(stride = 1\)</span></p></li>
<li><p><span class="math inline">\(kernel\ size = 3\)</span></p></li>
<li><p><span class="math inline">\(padding = (1,\ 1)\)</span></p></li>
</ul></li>
<li><p>Layer 2</p>
<ul>
<li><p><span class="math inline">\(stride = 1\)</span></p></li>
<li><p><span class="math inline">\(kernel\ size = 3\)</span></p></li>
<li><p><span class="math inline">\(padding = (2,\ 2)\)</span></p></li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/drawing_5.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="1000"></p>
</figure>
</div>
<p>Let us see how the causal reconfiguration is applied to each layer.</p>
<section id="layer-1" class="level3">
<h3 class="anchored" data-anchor-id="layer-1">Layer 1</h3>
<section id="reconfiguration" class="level4">
<h4 class="anchored" data-anchor-id="reconfiguration">Reconfiguration</h4>
<p>The reconfiguration moves the right padding to the left of the graph and thus, introduces a delay <span class="math inline">\(D_{1} = right\ pad = 1\)</span> compared to the initial non causal graph.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/drawing_6.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="1000"></p>
</figure>
</div>
</section>
<section id="inference" class="level4">
<h4 class="anchored" data-anchor-id="inference">Inference</h4>
<p>We note <span class="math inline">\(total\ pad = left\ pad + right\ pad\)</span> the total amount of padding.</p>
<p>For layer 1</p>
<ul>
<li><span class="math inline">\(total\ pad = 2\)</span>.</li>
</ul>
<p>During inference, these 3 steps are applied:</p>
<ul>
<li><p>The <span class="math inline">\(total\ pad\)</span> left pad values are filled with the last <span class="math inline">\(total\ pad\)</span> values of the previous buffer.</p></li>
<li><p>The last <span class="math inline">\(total\ pad\)</span> values of the current buffer are stored in the cache.</p></li>
<li><p>And the convolution is applied.</p></li>
</ul>
<p>Each step corresponds to one line in the figure below, see <a href="https://github.com/acids-ircam/cached_conv/blob/v2.3.6/cached_conv/convs.py#L119">here</a> for the original implementation.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/drawing_7.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="1000"></p>
</figure>
</div>
</section>
<section id="cumulated-delay" class="level4">
<h4 class="anchored" data-anchor-id="cumulated-delay">Cumulated delay</h4>
<p>Hence, for convolution layers with <span class="math inline">\(stride = 1\)</span></p>
<ul>
<li><p><span class="math inline">\(D_{l} = right\ pad\)</span></p></li>
<li><p><span class="math inline">\({Cumulated\ Delay}_{l} = \ {Cumulated\ Delay}_{l - 1} + D_{l}\)</span></p></li>
</ul>
<p>Which gives at layer 1</p>
<ul>
<li><p><span class="math inline">\(D_{1} = right\ pad = 1\)</span></p></li>
<li><p><span class="math inline">\({Cumulated\ Delay}_{1} = \ {Cumulated\ Delay}_{0} + D_{1} = 0 + 1 = 1\)</span></p></li>
</ul>
</section>
</section>
<section id="layer-2" class="level3">
<h3 class="anchored" data-anchor-id="layer-2">Layer 2</h3>
<section id="reconfiguration-1" class="level4">
<h4 class="anchored" data-anchor-id="reconfiguration-1">Reconfiguration</h4>
<p>The reconfiguration again moves the right padding to the left of the graph and thus, introduces a delay <span class="math inline">\(D_{2} = right\ pad = 2\)</span>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/drawing_8.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="1000"></p>
</figure>
</div>
</section>
<section id="inference-1" class="level4">
<h4 class="anchored" data-anchor-id="inference-1">Inference</h4>
<p>For layer 2</p>
<ul>
<li><span class="math inline">\(total\ pad = 4\)</span></li>
</ul>
<p>During inference, the same 3 steps as for layer 1 are applied.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/drawing_9.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="1000"></p>
</figure>
</div>
</section>
<section id="cumulated-delay-1" class="level4">
<h4 class="anchored" data-anchor-id="cumulated-delay-1">Cumulated delay</h4>
<p>The <span class="math inline">\(Cumulated\ Delay\)</span> at layer 2 is</p>
<ul>
<li><p><span class="math inline">\(D_{2} = right\ pad = 2\)</span></p></li>
<li><p><span class="math inline">\({Cumulated\ Delay}_{2} = \ {Cumulated\ Delay}_{1} + D_{2} = 1 + 2 = 3\)</span></p></li>
</ul>
</section>
</section>
<section id="summary" class="level3">
<h3 class="anchored" data-anchor-id="summary">Summary</h3>
<p>Below is a summary of all the steps explained above.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/drawing_10.svg" class="img-fluid quarto-figure quarto-figure-center figure-img" width="1000"></p>
</figure>
</div>
<p>For convolution layers with <span class="math inline">\(stride = 1\)</span></p>
<ul>
<li><p><span class="math inline">\(D_{l} = right\ pad\)</span></p></li>
<li><p><span class="math inline">\({Cumulated\ Delay}_{l} = \ {Cumulated\ Delay}_{l - 1} + D_{l}\)</span></p></li>
</ul>
</section>
</section>
<section id="convolution-layers-with-stride-1-1" class="level2">
<h2 class="anchored" data-anchor-id="convolution-layers-with-stride-1-1">Convolution layers with <span class="math inline">\(stride &gt; 1\)</span></h2>
<p>The figure below represents 2 convolution layers before the causal reconfiguration</p>
<ul>
<li><p>Layer 1</p>
<ul>
<li><p><span class="math inline">\(stride = 2\)</span></p></li>
<li><p><span class="math inline">\(kernel\ size = 3\)</span></p></li>
<li><p><span class="math inline">\(padding = (1,\ 1)\)</span></p></li>
</ul></li>
<li><p>Layer 2</p>
<ul>
<li><p><span class="math inline">\(stride = 2\)</span></p></li>
<li><p><span class="math inline">\(kernel\ size = 5\)</span></p></li>
<li><p><span class="math inline">\(padding = (2,\ 2)\)</span></p></li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/drawing_11.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="1000"></p>
</figure>
</div>
<p>Let us see how the causal reconfiguration is applied to each layer.</p>
<section id="layer-1-1" class="level3">
<h3 class="anchored" data-anchor-id="layer-1-1">Layer 1</h3>
<section id="reconfiguration-2" class="level4">
<h4 class="anchored" data-anchor-id="reconfiguration-2">Reconfiguration</h4>
<p>The reconfiguration moves the right padding to the left of the graph and thus, introduces a delay <span class="math inline">\(right\ pad = 1\)</span> compared to the initial non causal graph.</p>
<p>However, as can be seen below, this delay breaks the time alignment between the layer input and the convolution stride.</p>
<p>This means that without additional reconfiguration, the time alignment between the layer input and output is not preserved.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/drawing_12.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="1000"></p>
</figure>
</div>
<p>In order to align again the initial first value of the input tensor with the convolution stride, an additional <span class="math inline">\(stride\ delay\)</span> needs to be introduced</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/drawing_13.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="1000"></p>
</figure>
</div>
<p>This additional <span class="math inline">\(stride\ delay\)</span> is computed as follows</p>
<ul>
<li><p>Let us first consider the quantity <span class="math inline">\(A\)</span>.</p>
<ul>
<li><p><span class="math inline">\(A = (Cumulated\ Delay\  + \ right\ pad)\ \%\ stride\)</span></p></li>
<li><p>At layer 1, <span class="math inline">\({Cumulated\ Delay}_{0} = 0\)</span>. Hence, it is not visible in the figure above. Please refer to <a href="#reconfiguration-3">layer 2 reconfiguration</a> to see how <span class="math inline">\(Cumulated\ Delay\)</span> appears in the calculation.</p></li>
</ul></li>
<li><p><span class="math inline">\(stride\ delay\)</span> could be defined as equal to <span class="math inline">\(B = stride - A\)</span> but the case when <span class="math inline">\(A = 0\)</span> should be handled properly.</p>
<ul>
<li><p>Indeed, when <span class="math inline">\(A = 0\)</span>, the first value of the input tensor is aligned with the convolution stride.</p></li>
<li><p>Thus, <span class="math inline">\(stride\ delay\)</span> should be <span class="math inline">\(0\)</span>.</p></li>
<li><p>This can be achieved by defining <span class="math inline">\(stride\ delay\)</span> as <span class="math inline">\(stride\ delay = B\ \%\ stride\)</span>.</p></li>
<li><p>This means, <span class="math inline">\(stride\ delay = B\ \%\ stride = (stride - A)\ \%\ stride\)</span> and</p>
<ul>
<li><p>If <span class="math inline">\(A = 0\)</span></p>
<ul>
<li><span class="math inline">\(stride\ delay = (stride - 0)\ \%\ stride = 0\)</span></li>
</ul></li>
<li><p>Else</p>
<ul>
<li><p>Because <span class="math inline">\(A = (Cumulated\ Delay\  + \ right\ pad)\ \%\ stride\)</span>),</p></li>
<li><p>We have <span class="math inline">\(0 &lt; A &lt; stride\)</span>,</p></li>
<li><p>And thus, <span class="math inline">\(stride\ delay = (stride - A)\ \%\ stride = stride - A\)</span></p></li>
</ul></li>
</ul></li>
<li><p>Giving hence the expected behavior.</p></li>
</ul></li>
<li><p>To summarize:</p></li>
</ul>
<p><span class="math inline">\(stride\ delay = B\ \%\ stride\)</span></p>
<p><span class="math inline">\(stride\ delay = (stride - A)\ \%\ stride\)</span></p>
<p><span class="math inline">\(stride\ delay = (stride - (Cumulated\ Delay\  + \ right\ pad)\ \%\ stride)\ \%\ stride\)</span></p>
<ul>
<li>The implementation of this computation can be found <a href="https://github.com/acids-ircam/cached_conv/blob/v2.3.6/cached_conv/convs.py#L112">here</a>.</li>
</ul>
<p>For layer 1</p>
<ul>
<li><span class="math inline">\(stride\ delay\)</span><br>
<span class="math inline">\(= (stride - (Cumulated\ Delay\  + \ right\ pad)\ \%\ stride)\ \%\ stride\)</span><br>
<span class="math inline">\(= (2 - (0 + \ 1)\ \%\ 2)\ \%\ 2\)</span><br>
<span class="math inline">\(= 1\)</span></li>
</ul>
</section>
<section id="inference-2" class="level4">
<h4 class="anchored" data-anchor-id="inference-2">Inference</h4>
<p>For layer 1</p>
<ul>
<li><span class="math inline">\(stride\ delay = 1\)</span></li>
</ul>
<!-- -->
<ul>
<li><span class="math inline">\(total\ pad = 2\)</span></li>
</ul>
<p>During inference, 3 additional steps are applied in addition to the 3 steps explained above when <span class="math inline">\(stride = 1\)</span>.</p>
<p>The first 3 steps handle the <span class="math inline">\(stride\ delay\)</span> introduced to preserve the stride alignment while the 3 other steps handle the causal reconfiguration of the right padding as seen before.</p>
<p>The 6 steps are:</p>
<ul>
<li><p>The first <span class="math inline">\(stride\ delay\)</span> values are filled with the last <span class="math inline">\(stride\ delay\)</span> values of the previous buffer.</p></li>
<li><p>The last <span class="math inline">\(stride\ delay\)</span> values of the current buffer are stored in the cache.</p></li>
<li><p>The resulting tensor is cropped (the last <span class="math inline">\(stride\ delay\)</span> values are dropped).</p>
<ul>
<li><p>This is done to preserve the time dimensionality of the input tensor.</p></li>
<li><p>The dropped values are not lost because they will be processed by the next buffer.</p></li>
<li><p>However, a slight discontinuity seems to occur. See <a href="#notes-on-the-continuity-between-buffers">Notes on the continuity between buffers</a> for more details.</p></li>
</ul></li>
<li><p>The <span class="math inline">\(total\ pad\)</span> left pad values are filled with the last <span class="math inline">\(total\ pad\)</span> values of the previous buffer.</p></li>
<li><p>The last <span class="math inline">\(total\ pad\)</span> values of the current buffer are stored in the cache.</p></li>
<li><p>And the convolution is applied.</p></li>
</ul>
<p>Each step corresponds to one line in the figure below, see <a href="https://github.com/acids-ircam/cached_conv/blob/v2.3.6/cached_conv/convs.py#L119">here</a> for the original implementation.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/drawing_14.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="1000"></p>
</figure>
</div>
</section>
<section id="cumulated-delay-2" class="level4">
<h4 class="anchored" data-anchor-id="cumulated-delay-2">Cumulated delay</h4>
<p>For convolution layers with <span class="math inline">\(stride &gt; 1\)</span></p>
<ul>
<li><p><span class="math inline">\(D_{l} = stride\ delay + right\ pad\)</span></p></li>
<li><p><span class="math inline">\({Cumulated\ Delay}_{l} = ({Cumulated\ Delay}_{l - 1} + D_{l})\ //\ stride\)</span></p></li>
<li><p>The <span class="math inline">\(//\ stride\)</span> division allows to express the delay in the unit of the output space.</p>
<ul>
<li>Indeed, <span class="math inline">\(1\ output\ sample = stride\ input\ samples\)</span></li>
</ul></li>
</ul>
<p>This gives at layer 1</p>
<ul>
<li><p><span class="math inline">\(D_{1} = stride\ delay + right\ pad = 1 + 2 = 3\)</span></p></li>
<li><p><span class="math inline">\({Cumulated\ Delay}_{1}\)</span><br>
<span class="math inline">\(= ({Cumulated\ Delay}_{0} + D_{1})\ //\ stride\)</span><br>
<span class="math inline">\(= (0 + 1 + 1)\ //\ 2\)</span><br>
<span class="math inline">\(= 1\)</span></p></li>
</ul>
</section>
</section>
<section id="layer-2-1" class="level3">
<h3 class="anchored" data-anchor-id="layer-2-1">Layer 2</h3>
<section id="reconfiguration-3" class="level4">
<h4 class="anchored" data-anchor-id="reconfiguration-3">Reconfiguration</h4>
<p>As for layer 1, in order to align again the initial first value of the input tensor with the convolution stride, an additional <span class="math inline">\(stride\ delay\)</span> needs to be introduced</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/drawing_15.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="1000"></p>
</figure>
</div>
<p>This additional <span class="math inline">\(stride\ delay\)</span> is computed as follows</p>
<ul>
<li><span class="math inline">\(stride\ delay\)</span><br>
<span class="math inline">\(= (stride - (Cumulated\ Delay\  + \ right\ pad)\ \%\ stride)\ \%\ stride\)</span><br>
<span class="math inline">\(= (2 - (1 + \ 2)\ \%\ 2)\ \%\ 2\)</span><br>
<span class="math inline">\(= 1\)</span></li>
</ul>
</section>
<section id="inference-3" class="level4">
<h4 class="anchored" data-anchor-id="inference-3">Inference</h4>
<p>For layer 2</p>
<ul>
<li><span class="math inline">\(stride\ delay = 1\)</span></li>
</ul>
<!-- -->
<ul>
<li><span class="math inline">\(total\ pad = 4\)</span></li>
</ul>
<p>During inference, the same 6 steps as for layer 1 are applied.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/drawing_16.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="1000"></p>
</figure>
</div>
</section>
<section id="cumulated-delay-3" class="level4">
<h4 class="anchored" data-anchor-id="cumulated-delay-3">Cumulated delay</h4>
<p>The <span class="math inline">\(Cumulated\ Delay\)</span> at layer 2 is</p>
<ul>
<li><p><span class="math inline">\(D_{2} = stride\ delay + right\ pad = 1 + 2 = 3\)</span></p></li>
<li><p><span class="math inline">\({Cumulated\ Delay}_{2}\)</span><br>
<span class="math inline">\(= ({Cumulated\ Delay}_{1} + D_{2})\ //\ stride\)</span><br>
<span class="math inline">\(= (1 + 3)\ //\ 2\)</span><br>
<span class="math inline">\(= 2\)</span></p></li>
</ul>
</section>
</section>
<section id="summary-1" class="level3">
<h3 class="anchored" data-anchor-id="summary-1">Summary</h3>
<p>Below is a summary of all the steps explained above.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/drawing_17.svg" class="img-fluid quarto-figure quarto-figure-center figure-img" width="1000"></p>
</figure>
</div>
<p>For convolution layers with <span class="math inline">\(stride &gt; 1\)</span></p>
<ul>
<li><span class="math inline">\(stride\ delay = (stride - ({Cumulated\ Delay}_{l - 1} + \ right\ pad)\ \%\ stride)\ \%\ stride\)</span></li>
</ul>
<!-- -->
<ul>
<li><p><span class="math inline">\(D_{l} = stride\ delay + right\ pad\)</span></p></li>
<li><p><span class="math inline">\({Cumulated\ Delay}_{l} = ({Cumulated\ Delay}_{l - 1} + D_{l})\ //\ stride\)</span></p></li>
</ul>
</section>
<section id="notes-on-the-continuity-between-buffers" class="level3">
<h3 class="anchored" data-anchor-id="notes-on-the-continuity-between-buffers">Notes on the continuity between buffers</h3>
<ul>
<li><p>The explanations given in this <a href="#convolution-layers-with-stride-1-1">Convolution layers with stride&gt;1</a> section correspond to the <a href="https://arxiv.org/abs/2204.07064">Streamable Neural Audio Synthesis With Non-Causal Convolutions</a> paper and its official implementation <a href="https://github.com/acids-ircam/RAVE/tree/v1">RAVE v1</a>.</p></li>
<li><p>The proposed solution allows to make the convolutions causal while maintaining the stride alignment.</p></li>
<li><p>However, a slight discontinuity in the processing of the input audio stream seems to remain.</p></li>
<li><p>The figure below shows how 2 contiguous buffers are processed.</p>
<ul>
<li><p>As can be seen, the stride alignment is correct (green rectangles).</p></li>
<li><p>However, the stride between the receptive fields of the layers over their input stream seems not to be constant around the point of contact between two buffers (red rectangles).</p></li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="media/drawing_18.svg" class="img-fluid quarto-figure quarto-figure-center figure-img" width="1000"></p>
</figure>
</div>
<ul>
<li><p>Despite this possible discontinuity, the <a href="https://arxiv.org/abs/2204.07064">Streamable Neural Audio Synthesis With Non-Causal Convolutions</a> paper reports no difference between the outputs of the studied RAVE model before and after the causal reconfiguration (figure 8 of the paper).</p></li>
<li><p>This suggests that either the discontinuity has a negligible effect on the output quality or that I have missed something and there is no such discontinuity.</p></li>
</ul>
</section>
</section>
<section id="convolution-layers-summary" class="level2">
<h2 class="anchored" data-anchor-id="convolution-layers-summary">Convolution layers summary</h2>
<p>For convolution layers with <span class="math inline">\(stride &gt; 1\)</span></p>
<ul>
<li><span class="math inline">\(stride\ delay = (stride - ({Cumulated\ Delay}_{l - 1} + \ right\ pad)\ \%\ stride)\ \%\ stride\)</span></li>
</ul>
<!-- -->
<ul>
<li><p><span class="math inline">\(D_{l} = stride\ delay + right\ pad\)</span></p></li>
<li><p><span class="math inline">\({Cumulated\ Delay}_{l} = ({Cumulated\ Delay}_{l - 1} + D_{l})\ //\ stride\)</span></p></li>
</ul>
<p>Which, simplifies for <span class="math inline">\(stride = 1\)</span> to</p>
<ul>
<li><p><span class="math inline">\(stride\ delay = 0\)</span> (because <span class="math inline">\(x\ \%\ 1 = 0\)</span>)</p></li>
<li><p><span class="math inline">\(D_{l} = right\ pad\)</span></p></li>
<li><p><span class="math inline">\({Cumulated\ Delay}_{l} = {Cumulated\ Delay}_{l - 1} + D_{l}\)</span></p></li>
</ul>
</section>
<section id="parallel-branches" class="level2">
<h2 class="anchored" data-anchor-id="parallel-branches">Parallel branches</h2>
<p>Similarly the convolution layers, parallel branches in the computational graph need to be handled after the causal reconfiguration.</p>
<p>Indeed, each branch introduces its own delay, depending on the layers that compose it.</p>
<p>Before merging parallel branches, for example in the element-wise sum layer in a residual connection, all the parallel branches need to be aligned to compensate for their different individual delays.</p>
<p>This is simply done by aligning all the parallel branches to the maximum delay. Hence, an additional <span class="math inline">\({Alignment\ Delay}_{i}\)</span> is added to each branch <span class="math inline">\(i\)</span>:</p>
<p><span class="math inline">\({Alignment\ Delay}_{i} = Maximum\ Cumulated\ Delay\  - {Cumulated\ Delay}_{i}\)</span></p>
<p>where <span class="math inline">\(Maximum\ Cumulated\ Delay\)</span> is the cumulated delay of the branch with the largest cumulated delay.</p>
</section>
</section>
<section id="sources" class="level1">
<h1>Sources</h1>
<section id="papers" class="level3">
<h3 class="anchored" data-anchor-id="papers">Papers</h3>
<ul>
<li><p><a href="https://arxiv.org/abs/2204.07064">Streamable Neural Audio Synthesis With Non-Causal Convolutions</a></p></li>
<li><p><a href="https://arxiv.org/abs/2005.06720">Streaming keyword spotting on mobile devices</a></p></li>
</ul>
</section>
<section id="code" class="level3">
<h3 class="anchored" data-anchor-id="code">Code</h3>
<ul>
<li><p><a href="https://github.com/acids-ircam/RAVE/tree/v1">RAVE v1</a></p></li>
<li><p><a href="https://github.com/acids-ircam/cached_conv/tree/v2.3.6">cached_conv v2.3.6</a></p></li>
</ul>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/nisace\.github\.io\/personal-website\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>